Question,Answer
What is Python?,"A high-level, interpreted programming language."
Who created Python?,Guido van Rossum.
When was Python first released?,1991
Is Python free?,"Yes, it's open-source."
What does 'Python' mean?,Named after 'Monty PythonÉ??s Flying Circus'.
What is PEP 8?,Python's official style guide.
Is Python compiled or interpreted?,Interpreted.
What is a variable in Python?,A name that refers to a value.
How do you print in Python?,Use the print() function.
How do you take input in Python?,Use the input() function.
What is a list?,"A mutable, ordered collection."
What is a tuple?,"An immutable, ordered collection."
What is a dictionary?,A key-value mapping.
What is a set?,An unordered collection of unique items.
How do you comment in Python?,Use # for single-line comments.
What is indentation?,Defines code blocks.
What is an if statement?,Used for conditional execution.
What is a for loop?,Iterates over a sequence.
What is a while loop?,Repeats as long as a condition is true.
What is break?,Exits the loop.
What is continue?,Skips to the next iteration.
What is pass?,A null statement that does nothing.
How do you define a function?,Using def keyword.
What is return?,Sends a value back from a function.
What are default arguments?,Function parameters with default values.
What is a module?,A file with Python code.
How do you import a module?,Using import keyword.
What is __name__ == '__main__'?,Checks if script is run directly.
What is a class?,A blueprint for objects.
What is self?,Refers to the instance of the class.
What is inheritance?,Deriving a class from another.
What is polymorphism?,Same interface for different types.
What is encapsulation?,Restricting access to data.
What is a generator?,Function that yields values.
What is a decorator?,Function that modifies another.
What is a lambda function?,An anonymous function.
What is list comprehension?,Concise way to create lists.
What is with used for?,Context management.
What is try/except?,Error handling.
What is finally?,Code that runs after try/except.
What is raise?,Raises an exception.
How do you install Python?,Download from python.org.
How to check Python version?,Use python --version.
What is pip?,Python package installer.
How to install a package?,Use pip install package_name.
What is venv?,Tool to create virtual environments.
How to activate venv?,Use source or Scripts/activate.
What is NumPy?,Library for numerical computing.
What is Pandas?,Library for data analysis.
What is Matplotlib?,Library for plotting.
What is Django?,Python web framework.
How do I submit bug reports and patches for Python?,"To report a bug or submit a patch, use the issue tracker at https://github.com/python/cpython/issues. For more information on how Python is developed, consult the Python DeveloperÉ??s Guide. Are there any published articles about Python that I can reference? ItÉ??s probably best to cite your favorite book about Python. The very first article about Python was written in 1991 and is now quite outdated. Guido van Rossum and Jelke de Boer, É??Interactively Testing Remote Servers Using the Python Programming LanguageÉ?ù, CWI Quarterly, Volume 4, Issue 4 (December 1991), Amsterdam, pp 283É??303. Are there any books on Python? Yes, there are many, and more are being published. See the python.org wiki at https://wiki.python.org/moin/PythonBooks for a list. You can also search online bookstores for É??PythonÉ?ù and filter out the Monty Python references; or perhaps search for É??PythonÉ?ù and É??languageÉ?ù. Where in the world is www.python.org located? The Python projectÉ??s infrastructure is located all over the world and is managed by the Python Infrastructure Team. Details here."
Why is it called Python?,"When he began implementing Python, Guido van Rossum was also reading the published scripts from É??Monty PythonÉ??s Flying CircusÉ?ù, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python. Do I have to like É??Monty PythonÉ??s Flying CircusÉ?ù? No, but it helps. :) Python in the real world"
How stable is Python?,"Very stable. New, stable releases have been coming out roughly every 6 to 18 months since 1991, and this seems likely to continue. As of version 3.9, Python will have a new feature release every 12 months (PEP 602). The developers issue bugfix releases of older versions, so the stability of existing releases gradually improves. Bugfix releases, indicated by a third component of the version number (e.g. 3.5.3, 3.6.2), are managed for stability; only fixes for known problems are included in a bugfix release, and itÉ??s guaranteed that interfaces will remain the same throughout a series of bugfix releases. The latest stable releases can always be found on the Python download page. Python 3.x is the recommended version and supported by most widely used libraries. Python 2.x is not maintained anymore."
How many people are using Python?,"There are probably millions of users, though itÉ??s difficult to obtain an exact count. Python is available for free download, so there are no sales figures, and itÉ??s available from many different sites and packaged with many Linux distributions, so download statistics donÉ??t tell the whole story either. The comp.lang.python newsgroup is very active, but not all Python users post to the group or even read it. Have any significant projects been done in Python? See https://www.python.org/about/success for a list of projects that use Python. Consulting the proceedings for past Python conferences will reveal contributions from many different companies and organizations. High-profile Python projects include the Mailman mailing list manager and the Zope application server. Several Linux distributions, most notably Red Hat, have written part or all of their installer and system administration software in Python. Companies that use Python internally include Google, Yahoo, and Lucasfilm Ltd."
What new developments are expected for Python in the future?,"See https://peps.python.org/ for the Python Enhancement Proposals (PEPs). PEPs are design documents describing a suggested new feature for Python, providing a concise technical specification and a rationale. Look for a PEP titled É??Python X.Y Release ScheduleÉ?ù, where X.Y is a version that hasnÉ??t been publicly released yet. New development is discussed on the python-dev mailing list."
Is it reasonable to propose incompatible changes to Python?,"In general, no. There are already millions of lines of Python code around the world, so any change in the language that invalidates more than a very small fraction of existing programs has to be frowned upon. Even if you can provide a conversion program, thereÉ??s still the problem of updating all documentation; many books have been written about Python, and we donÉ??t want to invalidate them all at a single stroke. Providing a gradual upgrade path is necessary if a feature has to be changed. PEP 5 describes the procedure followed for introducing backward-incompatible changes while minimizing disruption for users."
Is Python a good language for beginning programmers?,"Yes. It is still common to start students with a procedural and statically typed language such as Pascal, C, or a subset of C++ or Java. Students may be better served by learning Python as their first language. Python has a very simple and consistent syntax and a large standard library and, most importantly, using Python in a beginning programming course lets students concentrate on important programming skills such as problem decomposition and data type design. With Python, students can be quickly introduced to basic concepts such as loops and procedures. They can probably even work with user-defined objects in their very first course. For a student who has never programmed before, using a statically typed language seems unnatural. It presents additional complexity that the student must master and slows the pace of the course. The students are trying to learn to think like a computer, decompose problems, design consistent interfaces, and encapsulate data. While learning to use a statically typed language is important in the long term, it is not necessarily the best topic to address in the studentsÉ?? first programming course. Many other aspects of Python make it a good first language. Like Java, Python has a large standard library so that students can be assigned programming projects very early in the course that do something. Assignments arenÉ??t restricted to the standard four-function calculator and check balancing programs. By using the standard library, students can gain the satisfaction of working on realistic applications as they learn the fundamentals of programming. Using the standard library also teaches students about code reuse. Third-party modules such as PyGame are also helpful in extending the studentsÉ?? reach. PythonÉ??s interactive interpreter enables students to test language features while theyÉ??re programming. They can keep a window with the interpreter running while they enter their programÉ??s source in another window. If they canÉ??t remember the methods for a list, they can do something like this: L = [] dir(L) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] [d for d in dir(L) if '__' not in d] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] help(L.append) Help on built-in function append: append(...) L.append(object) -> None -- append object to end L.append(1) L [1] With the interpreter, documentation is never far from the student as they are programming. There are also good IDEs for Python. IDLE is a cross-platform IDE for Python that is written in Python using Tkinter. Emacs users will be happy to know that there is a very good Python mode for Emacs. All of these programming environments provide syntax highlighting, auto-indenting, and access to the interactive interpreter while coding. Consult the Python wiki for a full list of Python editing environments. If you want to discuss PythonÉ??s use in education, you may be interested in joining the edu-sig mailing list."
What GUI toolkits exist for Python?,Tkinter questions
Can I have Tk events handled while waiting for I/O?,I canÉ??t get key bindings to work in Tkinter: why? General GUI Questions
What GUI toolkits exist for Python?,"Standard builds of Python include an object-oriented interface to the Tcl/Tk widget set, called tkinter. This is probably the easiest to install (since it comes included with most binary distributions of Python) and use. For more info about Tk, including pointers to the source, see the Tcl/Tk home page. Tcl/Tk is fully portable to the macOS, Windows, and Unix platforms. Depending on what platform(s) you are aiming at, there are also several alternatives. A list of cross-platform and platform-specific GUI frameworks can be found on the python wiki. Tkinter questions"
How do I freeze Tkinter applications?,"Freeze is a tool to create stand-alone applications. When freezing Tkinter applications, the applications will not be truly stand-alone, as the application will still need the Tcl and Tk libraries. One solution is to ship the application with the Tcl and Tk libraries, and point to them at run-time using the TCL_LIBRARY and TK_LIBRARY environment variables. Various third-party freeze libraries such as py2exe and cx_Freeze have handling for Tkinter applications built-in."
Can I have Tk events handled while waiting for I/O?,"On platforms other than Windows, yes, and you donÉ??t even need threads! But youÉ??ll have to restructure your I/O code a bit. Tk has the equivalent of XtÉ??s XtAddInput() call, which allows you to register a callback function which will be called from the Tk mainloop when I/O is possible on a file descriptor. See File Handlers. I canÉ??t get key bindings to work in Tkinter: why? An often-heard complaint is that event handlers bound to events with the bind() method donÉ??t get handled even when the appropriate key is pressed. The most common cause is that the widget to which the binding applies doesnÉ??t have É??keyboard focusÉ?ù. Check out the Tk documentation for the focus command. Usually a widget is given the keyboard focus by clicking in it (but not for labels; see the takefocus option)."
How do I find a module or application to perform task X?,"Check the Library Reference to see if thereÉ??s a relevant standard library module. (Eventually youÉ??ll learn whatÉ??s in the standard library and will be able to skip this step.) For third-party packages, search the Python Package Index or try Google or another web search engine. Searching for É??PythonÉ?ù plus a keyword or two for your topic of interest will usually find something helpful. Where is the math.py (socket.py, regex.py, etc.) source file? If you canÉ??t find a source file for a module it may be a built-in or dynamically loaded module implemented in C, C++ or other compiled language. In this case you may not have the source file or it may be something like mathmodule.c, somewhere in a C source directory (not on the Python Path). There are (at least) three kinds of modules in Python: modules written in Python (.py); modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc); modules written in C and linked with the interpreter; to get a list of these, type: import sys print(sys.builtin_module_names)"
How do I make a Python script executable on Unix?,"You need to do two things: the script fileÉ??s mode must be executable and the first line must begin with #! followed by the path of the Python interpreter. The first is done by executing chmod +x scriptfile or perhaps chmod 755 scriptfile. The second can be done in a number of ways. The most straightforward way is to write #!/usr/local/bin/python as the very first line of your file, using the pathname for where the Python interpreter is installed on your platform. If you would like the script to be independent of where the Python interpreter lives, you can use the env program. Almost all Unix variants support the following, assuming the Python interpreter is in a directory on the userÉ??s PATH: #!/usr/bin/env python DonÉ??t do this for CGI scripts. The PATH variable for CGI scripts is often very minimal, so you need to use the actual absolute pathname of the interpreter. Occasionally, a userÉ??s environment is so full that the /usr/bin/env program fails; or thereÉ??s no env program at all. In that case, you can try the following hack (due to Alex Rezinsky): #! /bin/sh """""":"" exec python $0 ${1+""$@""} """""" The minor disadvantage is that this defines the scriptÉ??s __doc__ string. However, you can fix that by adding __doc__ = """"""...Whatever..."""""""
Is there a curses/termcap package for Python?,"For Unix variants: The standard Python source distribution comes with a curses module in the Modules subdirectory, though itÉ??s not compiled by default. (Note that this is not available in the Windows distribution É?? there is no curses module for Windows.) The curses module supports basic curses features as well as many additional functions from ncurses and SYSV curses such as colour, alternative character set support, pads, and mouse support. This means the module isnÉ??t compatible with operating systems that only have BSD curses, but there donÉ??t seem to be any currently maintained OSes that fall into this category."
Is there an equivalent to CÉ??s onexit() in Python?,The atexit module provides a register function that is similar to CÉ??s onexit().
Why donÉ??t my signal handlers work?,"The most common problem is that the signal handler is declared with the wrong argument list. It is called as handler(signum, frame) so it should be declared with two parameters: def handler(signum, frame): ... Common tasks"
How do I test a Python program or component?,"Python comes with two testing frameworks. The doctest module finds examples in the docstrings for a module and runs them, comparing the output with the expected output given in the docstring. The unittest module is a fancier testing framework modelled on Java and Smalltalk testing frameworks. To make testing easier, you should use good modular design in your program. Your program should have almost all functionality encapsulated in either functions or class methods É?? and this sometimes has the surprising and delightful effect of making the program run faster (because local variable accesses are faster than global accesses). Furthermore the program should avoid depending on mutating global variables, since this makes testing much more difficult to do. The É??global main logicÉ?ù of your program may be as simple as if __name__ == ""__main__"": main_logic() at the bottom of the main module of your program. Once your program is organized as a tractable collection of function and class behaviours, you should write test functions that exercise the behaviours. A test suite that automates a sequence of tests can be associated with each module. This sounds like a lot of work, but since Python is so terse and flexible itÉ??s surprisingly easy. You can make coding much more pleasant and fun by writing your test functions in parallel with the É??production codeÉ?ù, since this makes it easy to find bugs and even design flaws earlier. É??Support modulesÉ?ù that are not intended to be the main module of a program may include a self-test of the module. if __name__ == ""__main__"": self_test() Even programs that interact with complex external interfaces may be tested when the external interfaces are unavailable by using É??fakeÉ?ù interfaces implemented in Python."
How do I create documentation from doc strings?,The pydoc module can create HTML from the doc strings in your Python source code. An alternative for creating API documentation purely from docstrings is epydoc. Sphinx can also include docstring content.
How do I get a single keypress at a time?,"For Unix variants there are several solutions. ItÉ??s straightforward to do this using curses, but curses is a fairly large module to learn. Threads"
How do I program using threads?,"Be sure to use the threading module and not the _thread module. The threading module builds convenient abstractions on top of the low-level primitives provided by the _thread module. None of my threads seem to run: why? As soon as the main thread exits, all threads are killed. Your main thread is running too quickly, giving the threads no time to do any work. A simple fix is to add a sleep to the end of the program thatÉ??s long enough for all the threads to finish: import threading, time def thread_task(name, n): for i in range(n): print(name, i) for i in range(10): T = threading.Thread(target=thread_task, args=(str(i), i)) T.start() time.sleep(10)  # <---------------------------! But now (on many platforms) the threads donÉ??t run in parallel, but appear to run sequentially, one at a time! The reason is that the OS thread scheduler doesnÉ??t start a new thread until the previous thread is blocked. A simple fix is to add a tiny sleep to the start of the run function: def thread_task(name, n): time.sleep(0.001)  # <--------------------! for i in range(n): print(name, i) for i in range(10): T = threading.Thread(target=thread_task, args=(str(i), i)) T.start() time.sleep(10) Instead of trying to guess a good delay value for time.sleep(), itÉ??s better to use some kind of semaphore mechanism. One idea is to use the queue module to create a queue object, let each thread append a token to the queue when it finishes, and let the main thread read as many tokens from the queue as there are threads."
How do I parcel out work among a bunch of worker threads?,"The easiest way is to use the concurrent.futures module, especially the ThreadPoolExecutor class. Or, if you want fine control over the dispatching algorithm, you can write your own logic manually. Use the queue module to create a queue containing a list of jobs. The Queue class maintains a list of objects and has a .put(obj) method that adds items to the queue and a .get() method to return them. The class will take care of the locking necessary to ensure that each job is handed out exactly once. HereÉ??s a trivial example: import threading, queue, time # The worker thread gets jobs off the queue.  When the queue is empty, it # assumes there will be no more work and exits. # (Realistically workers will run until terminated.) def worker(): print('Running worker') time.sleep(0.1) while True: try: arg = q.get(block=False) except queue.Empty: print('Worker', threading.current_thread(), end=' ') print('queue empty') break else: print('Worker', threading.current_thread(), end=' ') print('running with argument', arg) time.sleep(0.5) # Create queue q = queue.Queue() # Start a pool of 5 workers for i in range(5): t = threading.Thread(target=worker, name='worker %i' % (i+1)) t.start() # Begin adding work to the queue for i in range(50): q.put(i) # Give threads time to run print('Main thread sleeping') time.sleep(5) When run, this will produce the following output: Running worker Running worker Running worker Running worker Running worker Main thread sleeping Worker <Thread(worker 1, started 130283832797456)> running with argument 0 Worker <Thread(worker 2, started 130283824404752)> running with argument 1 Worker <Thread(worker 3, started 130283816012048)> running with argument 2 Worker <Thread(worker 4, started 130283807619344)> running with argument 3 Worker <Thread(worker 5, started 130283799226640)> running with argument 4 Worker <Thread(worker 1, started 130283832797456)> running with argument 5 ... Consult the moduleÉ??s documentation for more details; the Queue class provides a featureful interface."
What kinds of global value mutation are thread-safe?,"A global interpreter lock (GIL) is used internally to ensure that only one thread runs in the Python VM at a time. In general, Python offers to switch among threads only between bytecode instructions; how frequently it switches can be set via sys.setswitchinterval(). Each bytecode instruction and therefore all the C implementation code reached from each instruction is therefore atomic from the point of view of a Python program. In theory, this means an exact accounting requires an exact understanding of the PVM bytecode implementation. In practice, it means that operations on shared variables of built-in data types (ints, lists, dicts, etc) that É??look atomicÉ?ù really are. For example, the following operations are all atomic (L, L1, L2 are lists, D, D1, D2 are dicts, x, y are objects, i, j are ints): L.append(x) L1.extend(L2) x = L[i] x = L.pop() L1[i:j] = L2 L.sort() x = y x.field = y D[x] = y D1.update(D2) D.keys() These arenÉ??t: i = i+1 L.append(L[-1]) L[i] = L[j] D[x] = D[x] + 1 Operations that replace other objects may invoke those other objectsÉ?? __del__() method when their reference count reaches zero, and that can affect things. This is especially true for the mass updates to dictionaries and lists. When in doubt, use a mutex!"
CanÉ??t we get rid of the Global Interpreter Lock?,"The global interpreter lock (GIL) is often seen as a hindrance to PythonÉ??s deployment on high-end multiprocessor server machines, because a multi-threaded Python program effectively only uses one CPU, due to the insistence that (almost) all Python code can only run while the GIL is held. With the approval of PEP 703 work is now underway to remove the GIL from the CPython implementation of Python. Initially it will be implemented as an optional compiler flag when building the interpreter, and so separate builds will be available with and without the GIL. Long-term, the hope is to settle on a single build, once the performance implications of removing the GIL are fully understood. Python 3.13 is likely to be the first release containing this work, although it may not be completely functional in this release. The current work to remove the GIL is based on a fork of Python 3.9 with the GIL removed by Sam Gross. Prior to that, in the days of Python 1.5, Greg Stein actually implemented a comprehensive patch set (the É??free threadingÉ?ù patches) that removed the GIL and replaced it with fine-grained locking. Adam Olsen did a similar experiment in his python-safethread project. Unfortunately, both of these earlier experiments exhibited a sharp drop in single-thread performance (at least 30% slower), due to the amount of fine-grained locking necessary to compensate for the removal of the GIL. The Python 3.9 fork is the first attempt at removing the GIL with an acceptable performance impact. The presence of the GIL in current Python releases doesnÉ??t mean that you canÉ??t make good use of Python on multi-CPU machines! You just have to be creative with dividing the work up between multiple processes rather than multiple threads. The ProcessPoolExecutor class in the new concurrent.futures module provides an easy way of doing so; the multiprocessing module provides a lower-level API in case you want more control over dispatching of tasks. Judicious use of C extensions will also help; if you use a C extension to perform a time-consuming task, the extension can release the GIL while the thread of execution is in the C code and allow other threads to get some work done. Some standard library modules such as zlib and hashlib already do this. An alternative approach to reducing the impact of the GIL is to make the GIL a per-interpreter-state lock rather than truly global. This was first implemented in Python 3.12 and is available in the C API. A Python interface to it is expected in Python 3.13. The main limitation to it at the moment is likely to be 3rd party extension modules, since these must be written with multiple interpreters in mind in order to be usable, so many older extension modules will not be usable. Input and Output"
How do I delete a file? (And other file questionsÉ??),"Use os.remove(filename) or os.unlink(filename); for documentation, see the os module. The two functions are identical; unlink() is simply the name of the Unix system call for this function. To remove a directory, use os.rmdir(); use os.mkdir() to create one. os.makedirs(path) will create any intermediate directories in path that donÉ??t exist. os.removedirs(path) will remove intermediate directories as long as theyÉ??re empty; if you want to delete an entire directory tree and its contents, use shutil.rmtree(). To rename a file, use os.rename(old_path, new_path). To truncate a file, open it using f = open(filename, ""rb+""), and use f.truncate(offset); offset defaults to the current seek position. ThereÉ??s also os.ftruncate(fd, offset) for files opened with os.open(), where fd is the file descriptor (a small integer). The shutil module also contains a number of functions to work on files including copyfile(), copytree(), and rmtree()."
How do I copy a file?,"The shutil module contains a copyfile() function. Note that on Windows NTFS volumes, it does not copy alternate data streams nor resource forks on macOS HFS+ volumes, though both are now rarely used. It also doesnÉ??t copy file permissions and metadata, though using shutil.copy2() instead will preserve most (though not all) of it."
How do I read (or write) binary data?,"To read or write complex binary data formats, itÉ??s best to use the struct module. It allows you to take a string containing binary data (usually numbers) and convert it to Python objects; and vice versa. For example, the following code reads two 2-byte integers and one 4-byte integer in big-endian format from a file: import struct with open(filename, ""rb"") as f: s = f.read(8) x, y, z = struct.unpack("">hhl"", s) The É??>É?? in the format string forces big-endian data; the letter É??hÉ?? reads one É??short integerÉ?ù (2 bytes), and É??lÉ?? reads one É??long integerÉ?ù (4 bytes) from the string. For data that is more regular (e.g. a homogeneous list of ints or floats), you can also use the array module. Note To read and write binary data, it is mandatory to open the file in binary mode (here, passing ""rb"" to open()). If you use ""r"" instead (the default), the file will be open in text mode and f.read() will return str objects rather than bytes objects. I canÉ??t seem to use os.read() on a pipe created with os.popen(); why? os.read() is a low-level function which takes a file descriptor, a small integer representing the opened file. os.popen() creates a high-level file object, the same type returned by the built-in open() function. Thus, to read n bytes from a pipe p created with os.popen(), you need to use p.read(n)."
How do I access the serial (RS232) port?,"For Win32, OSX, Linux, BSD, Jython, IronPython: pyserial For Unix, see a Usenet post by Mitch Chapman: https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
"Why doesnÉ??t closing sys.stdout (stdin, stderr) really close it?","Python file objects are a high-level layer of abstraction on low-level C file descriptors. For most file objects you create in Python via the built-in open() function, f.close() marks the Python file object as being closed from PythonÉ??s point of view, and also arranges to close the underlying C file descriptor. This also happens automatically in fÉ??s destructor, when f becomes garbage. But stdin, stdout and stderr are treated specially by Python, because of the special status also given to them by C. Running sys.stdout.close() marks the Python-level file object as being closed, but does not close the associated C file descriptor. To close the underlying C file descriptor for one of these three, you should first be sure thatÉ??s what you really want to do (e.g., you may confuse extension modules trying to do I/O). If it is, use os.close(): os.close(stdin.fileno()) os.close(stdout.fileno()) os.close(stderr.fileno()) Or you can use the numeric constants 0, 1 and 2, respectively. Network/Internet Programming"
What WWW tools are there for Python?,See the chapters titled Internet Protocols and Support and Internet Data Handling in the Library Reference Manual. Python has many modules that will help you build server-side and client-side web systems. A summary of available frameworks is maintained by Paul Boddie at https://wiki.python.org/moin/WebProgramming.
What module should I use to help with generating HTML?,You can find a collection of useful links on the Web Programming wiki page.
How do I send mail from a Python script?,"Use the standard library module smtplib. HereÉ??s a very simple interactive mail sender that uses it. This method will work on any host that supports an SMTP listener. import sys, smtplib fromaddr = input(""From: "") toaddrs  = input(""To: "").split(',') print(""Enter message, end with ^D:"") msg = '' while True: line = sys.stdin.readline() if not line: break msg += line # The actual mail send server = smtplib.SMTP('localhost') server.sendmail(fromaddr, toaddrs, msg) server.quit() A Unix-only alternative uses sendmail. The location of the sendmail program varies between systems; sometimes it is /usr/lib/sendmail, sometimes /usr/sbin/sendmail. The sendmail manual page will help you out. HereÉ??s some sample code: import os SENDMAIL = ""/usr/sbin/sendmail""  # sendmail location p = os.popen(""%s -t -i"" % SENDMAIL, ""w"") p.write(""To: receiver@example.com\n"") p.write(""Subject: test\n"") p.write(""\n"")  # blank line separating headers from body p.write(""Some text\n"") p.write(""some more text\n"") sts = p.close() if sts != 0: print(""Sendmail exit status"", sts)"
How do I avoid blocking in the connect() method of a socket?,"The select module is commonly used to help with asynchronous I/O on sockets. To prevent the TCP connect from blocking, you can set the socket to non-blocking mode. Then when you do the connect(), you will either connect immediately (unlikely) or get an exception that contains the error number as .errno. errno.EINPROGRESS indicates that the connection is in progress, but hasnÉ??t finished yet. Different OSes will return different values, so youÉ??re going to have to check whatÉ??s returned on your system. You can use the connect_ex() method to avoid creating an exception. It will just return the errno value. To poll, you can call connect_ex() again later É?? 0 or errno.EISCONN indicate that youÉ??re connected É?? or you can pass this socket to select.select() to check if itÉ??s writable. Note The asyncio module provides a general purpose single-threaded and concurrent asynchronous library, which can be used for writing non-blocking network code. The third-party Twisted library is a popular and feature-rich alternative. Databases Are there any interfaces to database packages in Python? Yes. Interfaces to disk-based hashes such as DBM and GDBM are also included with standard Python. There is also the sqlite3 module, which provides a lightweight disk-based relational database. Support for most relational databases is available. See the DatabaseProgramming wiki page for details."
How do you implement persistent objects in Python?,"The pickle library module solves this in a very general way (though you still canÉ??t store things like open files, sockets or windows), and the shelve library module uses pickle and (g)dbm to create persistent mappings containing arbitrary Python objects. Mathematics and Numerics"
How do I generate random numbers in Python?,"The standard module random implements a random number generator. Usage is simple: import random random.random() This returns a random floating-point number in the range [0, 1). There are also many other specialized generators in this module, such as: randrange(a, b) chooses an integer in the range [a, b). uniform(a, b) chooses a floating-point number in the range [a, b). normalvariate(mean, sdev) samples the normal (Gaussian) distribution. Some higher-level functions operate on sequences directly, such as: choice(S) chooses a random element from a given sequence. shuffle(L) shuffles a list in-place, i.e. permutes it randomly. ThereÉ??s also a Random class you can instantiate to create independent multiple random number generators."
"Is there a source code level debugger with breakpoints, single-stepping, etc.?","Yes. Several debuggers for Python are described below, and the built-in function breakpoint() allows you to drop into any of them. The pdb module is a simple but adequate console-mode debugger for Python. It is part of the standard Python library, and is documented in the Library Reference Manual. You can also write your own debugger by using the code for pdb as an example. The IDLE interactive development environment, which is part of the standard Python distribution (normally available as Tools/scripts/idle3), includes a graphical debugger. PythonWin is a Python IDE that includes a GUI debugger based on pdb. The PythonWin debugger colors breakpoints and has quite a few cool features such as debugging non-PythonWin programs. PythonWin is available as part of pywin32 project and as a part of the ActivePython distribution. Eric is an IDE built on PyQt and the Scintilla editing component. trepan3k is a gdb-like debugger. Visual Studio Code is an IDE with debugging tools that integrates with version-control software. There are a number of commercial Python IDEs that include graphical debuggers. They include: Wing IDE Komodo IDE PyCharm Are there tools to help find bugs or perform static analysis? Yes. Pylint and Pyflakes do basic checking that will help you catch bugs sooner. Static type checkers such as Mypy, Pyre, and Pytype can check type hints in Python source code."
How can I create a stand-alone binary from a Python script?,"You donÉ??t need the ability to compile Python to C code if all you want is a stand-alone program that users can download and run without having to install the Python distribution first. There are a number of tools that determine the set of modules required by a program and bind these modules together with a Python binary to produce a single executable. One is to use the freeze tool, which is included in the Python source tree as Tools/freeze. It converts Python byte code to C arrays; with a C compiler you can embed all your modules into a new program, which is then linked with the standard Python modules. It works by scanning your source recursively for import statements (in both forms) and looking for the modules in the standard Python path as well as in the source directory (for built-in modules). It then turns the bytecode for modules written in Python into C code (array initializers that can be turned into code objects using the marshal module) and creates a custom-made config file that only contains those built-in modules which are actually used in the program. It then compiles the generated C code and links it with the rest of the Python interpreter to form a self-contained binary which acts exactly like your script. The following packages can help with the creation of console and GUI executables: Nuitka (Cross-platform) PyInstaller (Cross-platform) PyOxidizer (Cross-platform) cx_Freeze (Cross-platform) py2app (macOS only) py2exe (Windows only) Are there coding standards or a style guide for Python programs? Yes. The coding style required for standard library modules is documented as PEP 8. Core Language"
Why am I getting an UnboundLocalError when the variable has a value?,"It can be a surprise to get the UnboundLocalError in previously working code when it is modified by adding an assignment statement somewhere in the body of a function. This code: x = 10 def bar(): print(x) bar() 10 works, but this code: x = 10 def foo(): print(x) x += 1 results in an UnboundLocalError: foo() Traceback (most recent call last): ... UnboundLocalError: local variable 'x' referenced before assignment This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope. Since the last statement in foo assigns a new value to x, the compiler recognizes it as a local variable. Consequently when the earlier print(x) attempts to print the uninitialized local variable and an error results. In the example above you can access the outer scope variable by declaring it global: x = 10 def foobar(): global x print(x) x += 1 foobar() 10 This explicit declaration is required in order to remind you that (unlike the superficially analogous situation with class and instance variables) you are actually modifying the value of the variable in the outer scope: print(x) 11 You can do a similar thing in a nested scope using the nonlocal keyword: def foo(): x = 10 def bar(): nonlocal x print(x) x += 1 bar() print(x) foo() 10 11"
What are the rules for local and global variables in Python?,"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the functionÉ??s body, itÉ??s assumed to be a local unless explicitly declared as global. Though a bit surprising at first, a momentÉ??s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, youÉ??d be using global all the time. YouÉ??d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects."
Why do lambdas defined in a loop with different values all return the same result?,"Assume you use a for loop to define a few different lambdas (or even plain functions), e.g.: squares = [] for x in range(5): squares.append(lambda: x**2) This gives you a list that contains 5 lambdas that calculate x**2. You might expect that, when called, they would return, respectively, 0, 1, 4, 9, and 16. However, when you actually try you will see that they all return 16: squares[2]() 16 squares[4]() 16 This happens because x is not local to the lambdas, but is defined in the outer scope, and it is accessed when the lambda is called É?? not when it is defined. At the end of the loop, the value of x is 4, so all the functions now return 4**2, i.e. 16. You can also verify this by changing the value of x and see how the results of the lambdas change: x = 8 squares[2]() 64 In order to avoid this, you need to save the values in variables local to the lambdas, so that they donÉ??t rely on the value of the global x: squares = [] for x in range(5): squares.append(lambda n=x: n**2) Here, n=x creates a new variable n local to the lambda and computed when the lambda is defined so that it has the same value that x had at that point in the loop. This means that the value of n will be 0 in the first lambda, 1 in the second, 2 in the third, and so on. Therefore each lambda will now return the correct result: squares[2]() 4 squares[4]() 16 Note that this behaviour is not peculiar to lambdas, but applies to regular functions too."
How do I share global variables across modules?,"The canonical way to share information across modules within a single program is to create a special module (often called config or cfg). Just import the config module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example: config.py: x = 0   # Default value of the 'x' configuration setting mod.py: import config config.x = 1 main.py: import config import mod print(config.x) Note that using a module is also the basis for implementing the singleton design pattern, for the same reason."
What are the É??best practicesÉ?ù for using import in a module?,"In general, donÉ??t use from modulename import *. Doing so clutters the importerÉ??s namespace, and makes it much harder for linters to detect undefined names. Import modules at the top of a file. Doing so makes it clear what other modules your code requires and avoids questions of whether the module name is in scope. Using one import per line makes it easy to add and delete module imports, but using multiple imports per line uses less screen space. ItÉ??s good practice if you import modules in the following order: standard library modules É?? e.g. sys, os, argparse, re third-party library modules (anything installed in PythonÉ??s site-packages directory) É?? e.g. dateutil, requests, PIL.Image locally developed modules It is sometimes necessary to move imports to a function or class to avoid problems with circular imports. Gordon McMillan says: Circular imports are fine where both modules use the É??import <module>É?ù form of import. They fail when the 2nd module wants to grab a name out of the first (É??from module import nameÉ?ù) and the import is at the top level. ThatÉ??s because names in the 1st are not yet available, because the first module is busy importing the 2nd. In this case, if the second module is only used in one function, then the import can easily be moved into that function. By the time the import is called, the first module will have finished initializing, and the second module can do its import. It may also be necessary to move imports out of the top level of code if some of the modules are platform-specific. In that case, it may not even be possible to import all of the modules at the top of the file. In this case, importing the correct modules in the corresponding platform-specific code is a good option. Only move imports into a local scope, such as inside a function definition, if itÉ??s necessary to solve a problem such as avoiding a circular import or are trying to reduce the initialization time of a module. This technique is especially helpful if many of the imports are unnecessary depending on how the program executes. You may also want to move imports into a function if the modules are only ever used in that function. Note that loading a module the first time may be expensive because of the one time initialization of the module, but loading a module multiple times is virtually free, costing only a couple of dictionary lookups. Even if the module name has gone out of scope, the module is probably available in sys.modules."
Why are default values shared between objects?,"This type of bug commonly bites neophyte programmers. Consider this function: def foo(mydict={}):  # Danger: shared reference to one dict for all calls ... compute something ... mydict[key] = value return mydict The first time you call this function, mydict contains a single item. The second time, mydict contains two items because when foo() begins executing, mydict starts out with an item already in it. It is often expected that a function call creates new objects for default values. This is not what happens. Default values are created exactly once, when the function is defined. If that object is changed, like the dictionary in this example, subsequent calls to the function will refer to this changed object. By definition, immutable objects such as numbers, strings, tuples, and None, are safe from change. Changes to mutable objects such as dictionaries, lists, and class instances can lead to confusion. Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use None as the default value and inside the function, check if the parameter is None and create a new list/dictionary/whatever if it is. For example, donÉ??t write: def foo(mydict={}): ... but: def foo(mydict=None): if mydict is None: mydict = {}  # create a new dict for local namespace This feature can be useful. When you have a function thatÉ??s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called É??memoizingÉ?ù, and can be implemented like this: # Callers can only provide two parameters and optionally pass _cache by keyword def expensive(arg1, arg2, *, _cache={}): if (arg1, arg2) in _cache: return _cache[(arg1, arg2)] # Calculate the value result = ... expensive computation ... _cache[(arg1, arg2)] = result           # Store result in the cache return result You could use a global variable containing a dictionary instead of the default value; itÉ??s a matter of taste."
How can I pass optional or keyword parameters from one function to another?,"Collect the arguments using the * and ** specifiers in the functionÉ??s parameter list; this gives you the positional arguments as a tuple and the keyword arguments as a dictionary. You can then pass these arguments when calling another function by using * and **: def f(x, *args, **kwargs): ... kwargs['width'] = '14.3c' ... g(x, *args, **kwargs)"
What is the difference between arguments and parameters?,"Parameters are defined by the names that appear in a function definition, whereas arguments are the values actually passed to a function when calling it. Parameters define what kind of arguments a function can accept. For example, given the function definition: def func(foo, bar=None, **kwargs): pass foo, bar and kwargs are parameters of func. However, when calling func, for example: func(42, bar=314, extra=somevar) the values 42, 314, and somevar are arguments."
Why did changing list É??yÉ?? also change list É??xÉ???,"If you wrote code like: x = [] y = x y.append(10) y [10] x [10] you might be wondering why appending an element to y changed x too. There are two factors that produce this result: Variables are simply names that refer to objects. Doing y = x doesnÉ??t create a copy of the list É?? it creates a new variable y that refers to the same object x refers to. This means that there is only one object (the list), and both x and y refer to it. Lists are mutable, which means that you can change their content. After the call to append(), the content of the mutable object has changed from [] to [10]. Since both the variables refer to the same object, using either name accesses the modified value [10]. If we instead assign an immutable object to x: x = 5  # ints are immutable y = x x = x + 1  # 5 can't be mutated, we are creating a new object here x 6 y 5 we can see that in this case x and y are not equal anymore. This is because integers are immutable, and when we do x = x + 1 we are not mutating the int 5 by incrementing its value; instead, we are creating a new object (the int 6) and assigning it to x (that is, changing which object x refers to). After this assignment we have two objects (the ints 6 and 5) and two variables that refer to them (x now refers to 6 but y still refers to 5). Some operations (for example y.append(10) and y.sort()) mutate the object, whereas superficially similar operations (for example y = y + [10] and sorted(y)) create a new object. In general in Python (and in all cases in the standard library) a method that mutates an object will return None to help avoid getting the two types of operations confused. So if you mistakenly write y.sort() thinking it will give you a sorted copy of y, youÉ??ll instead end up with None, which will likely cause your program to generate an easily diagnosed error."
"However, there is one class of operations where the same operation sometimes has different behaviors with different types: the augmented assignment operators. For example, += mutates lists but not tuples or ints (a_list += [1, 2, 3] is equivalent to a_list.extend([1, 2, 3]) and mutates a_list, whereas some_tuple += (1, 2, 3) and some_int += 1 create new objects).","In other words: If we have a mutable object (list, dict, set, etc.), we can use some specific operations to mutate it and all the variables that refer to it will see the change. If we have an immutable object (str, int, tuple, etc.), all the variables that refer to it will always see the same value, but operations that transform that value into a new value always return a new object. If you want to know if two variables refer to the same object or not, you can use the is operator, or the built-in function id()."
How do I write a function with output parameters (call by reference)?,"Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, thereÉ??s no alias between an argument name in the caller and callee, and so no call-by-reference per se. You can achieve the desired effect in a number of ways. By returning a tuple of the results: def func1(a, b): a = 'new-value'        # a and b are local names b = b + 1              # assigned to new objects return a, b            # return new values x, y = 'old-value', 99 func1(x, y) ('new-value', 100) This is almost always the clearest solution. By using global variables. This isnÉ??t thread-safe, and is not recommended. By passing a mutable (changeable in-place) object: def func2(a): a[0] = 'new-value'     # 'a' references a mutable list a[1] = a[1] + 1        # changes a shared object args = ['old-value', 99] func2(args) args ['new-value', 100] By passing in a dictionary that gets mutated: def func3(args): args['a'] = 'new-value'     # args is a mutable dictionary args['b'] = args['b'] + 1   # change it in-place args = {'a': 'old-value', 'b': 99} func3(args) args {'a': 'new-value', 'b': 100} Or bundle up values in a class instance: class Namespace: def __init__(self, /, **args): for key, value in args.items(): setattr(self, key, value) def func4(args): args.a = 'new-value'        # args is a mutable Namespace args.b = args.b + 1         # change object in-place args = Namespace(a='old-value', b=99) func4(args) vars(args) {'a': 'new-value', 'b': 100} ThereÉ??s almost never a good reason to get this complicated. Your best choice is to return a tuple containing the multiple results."
How do you make a higher order function in Python?,"You have two choices: you can use nested scopes or you can use callable objects. For example, suppose you wanted to define linear(a,b) which returns a function f(x) that computes the value a*x+b. Using nested scopes: def linear(a, b): def result(x): return a * x + b return result Or using a callable object: class linear: def __init__(self, a, b): self.a, self.b = a, b def __call__(self, x): return self.a * x + self.b In both cases, taxes = linear(0.3, 2) gives a callable object where taxes(10e6) == 0.3 * 10e6 + 2. The callable object approach has the disadvantage that it is a bit slower and results in slightly longer code. However, note that a collection of callables can share their signature via inheritance: class exponential(linear): # __init__ inherited def __call__(self, x): return self.a * (x ** self.b) Object can encapsulate state for several methods: class counter: value = 0 def set(self, x): self.value = x def up(self): self.value = self.value + 1 def down(self): self.value = self.value - 1 count = counter() inc, dec, reset = count.up, count.down, count.set Here inc(), dec() and reset() act like functions which share the same counting variable."
How do I copy an object in Python?,"In general, try copy.copy() or copy.deepcopy() for the general case. Not all objects can be copied, but most can. Some objects can be copied more easily. Dictionaries have a copy() method: newdict = olddict.copy() Sequences can be copied by slicing: new_l = l[:]"
How can I find the methods or attributes of an object?,"For an instance x of a user-defined class, dir(x) returns an alphabetized list of the names containing the instance attributes and methods and attributes defined by its class."
How can my code discover the name of an object?,"Generally speaking, it canÉ??t, because objects donÉ??t really have names. Essentially, assignment always binds a name to a value; the same is true of def and class statements, but in that case the value is a callable. Consider the following code: class A: pass B = A a = B() b = a print(b) <__main__.A object at 0x16D07CC> print(a) <__main__.A object at 0x16D07CC> Arguably the class has a name: even though it is bound to two names and invoked through the name B the created instance is still reported as an instance of class A. However, it is impossible to say whether the instanceÉ??s name is a or b, since both names are bound to the same value. Generally speaking it should not be necessary for your code to É??know the namesÉ?ù of particular values. Unless you are deliberately writing introspective programs, this is usually an indication that a change of approach might be beneficial. In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to this question: The same way as you get the name of that cat you found on your porch: the cat (object) itself cannot tell you its name, and it doesnÉ??t really care É?? so the only way to find out what itÉ??s called is to ask all your neighbours (namespaces) if itÉ??s their cat (object)É?? É??.and donÉ??t be surprised if youÉ??ll find that itÉ??s known by many names, or no name at all!"
WhatÉ??s up with the comma operatorÉ??s precedence?,"Comma is not an operator in Python. Consider this session: ""a"" in ""b"", ""a"" (False, 'a') Since the comma is not an operator, but a separator between expressions the above is evaluated as if you had entered: (""a"" in ""b""), ""a"" not: ""a"" in (""b"", ""a"") The same is true of the various assignment operators (=, += etc). They are not truly operators but syntactic delimiters in assignment statements."
Is there an equivalent of CÉ??s É???:É?ù ternary operator?,"Yes, there is. The syntax is as follows: [on_true] if [expression] else [on_false] x, y = 50, 25 small = x if x < y else y Before this syntax was introduced in Python 2.5, a common idiom was to use logical operators: [expression] and [on_true] or [on_false]"
Is it possible to write obfuscated one-liners in Python?,"Yes. Usually this is done by nesting lambda within lambda. See the following three examples, slightly adapted from Ulf Bartelt: from functools import reduce # Primes < 1000 print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0, map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000))))) # First 10 Fibonacci numbers print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1: f(x,f), range(10)))) # Mandelbrot set print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\n'+y,map(lambda y, Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM, Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro, i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr( 64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24)) #    \___ ___/  \___ ___/  |   |   |__ lines on screen #        V          V      |   |______ columns on screen #        |          |      |__________ maximum of ""iterations"" #        |          |_________________ range on y axis #        |____________________________ range on x axis DonÉ??t try this at home, kids!"
What does the slash(/) in the parameter list of a function mean?,"A slash in the argument list of a function denotes that the parameters prior to it are positional-only. Positional-only parameters are the ones without an externally usable name. Upon calling a function that accepts positional-only parameters, arguments are mapped to parameters based solely on their position. For example, divmod() is a function that accepts positional-only parameters. Its documentation looks like this: help(divmod) Help on built-in function divmod in module builtins: divmod(x, y, /) Return the tuple (x//y, x%y).  Invariant: div*y + mod == x. The slash at the end of the parameter list means that both parameters are positional-only. Thus, calling divmod() with keyword arguments would lead to an error: divmod(x=3, y=4) Traceback (most recent call last): File ""<stdin>"", line 1, in <module> TypeError: divmod() takes no keyword arguments Numbers and strings"
How do I specify hexadecimal and octal integers?,"To specify an octal digit, precede the octal value with a zero, and then a lower or uppercase É??oÉ?ù. For example, to set the variable É??aÉ?ù to the octal value É??10É?ù (8 in decimal), type: a = 0o10 a 8 Hexadecimal is just as easy. Simply precede the hexadecimal number with a zero, and then a lower or uppercase É??xÉ?ù. Hexadecimal digits can be specified in lower or uppercase. For example, in the Python interpreter: a = 0xa5 a 165 b = 0XB2 b 178"
Why does -22 // 10 return -3?,"ItÉ??s primarily driven by the desire that i % j have the same sign as j. If you want that, and also want: i == (i // j) * j + (i % j) then integer division has to return the floor. C also requires that identity to hold, and then compilers that truncate i // j need to make i % j have the same sign as i. There are few real use cases for i % j when j is negative. When j is positive, there are many, and in virtually all of them itÉ??s more useful for i % j to be >= 0. If the clock says 10 now, what did it say 200 hours ago? -190 % 12 == 2 is useful; -190 % 12 == -10 is a bug waiting to bite."
How do I get int literal attribute instead of SyntaxError?,"Trying to lookup an int literal attribute in the normal manner gives a SyntaxError because the period is seen as a decimal point: 1.__class__ File ""<stdin>"", line 1 1.__class__ ^ SyntaxError: invalid decimal literal The solution is to separate the literal from the period with either a space or parentheses. 1 .__class__ <class 'int'> (1).__class__ <class 'int'>"
How do I convert a string to a number?,"For integers, use the built-in int() type constructor, e.g. int('144') == 144. Similarly, float() converts to a floating-point number, e.g. float('144') == 144.0. By default, these interpret the number as decimal, so that int('0144') == 144 holds true, and int('0x144') raises ValueError. int(string, base) takes the base to convert from as a second optional argument, so int( '0x144', 16) == 324. If the base is specified as 0, the number is interpreted using PythonÉ??s rules: a leading É??0oÉ?? indicates octal, and É??0xÉ?? indicates a hex number. Do not use the built-in function eval() if all you need is to convert strings to numbers. eval() will be significantly slower and it presents a security risk: someone could pass you a Python expression that might have unwanted side effects. For example, someone could pass __import__('os').system(""rm -rf $HOME"") which would erase your home directory. eval() also has the effect of interpreting numbers as Python expressions, so that e.g. eval('09') gives a syntax error because Python does not allow leading É??0É?? in a decimal number (except É??0É??)."
How do I convert a number to a string?,"To convert, e.g., the number 144 to the string '144', use the built-in type constructor str(). If you want a hexadecimal or octal representation, use the built-in functions hex() or oct(). For fancy formatting, see the f-strings and Format String Syntax sections, e.g. ""{:04d}"".format(144) yields '0144' and ""{:.3f}"".format(1.0/3.0) yields '0.333'."
How do I modify a string in place?,"You canÉ??t, because strings are immutable. In most situations, you should simply construct a new string from the various parts you want to assemble it from. However, if you need an object with the ability to modify in-place unicode data, try using an io.StringIO object or the array module: import io s = ""Hello, world"" sio = io.StringIO(s) sio.getvalue() 'Hello, world' sio.seek(7) 7 sio.write(""there!"") 6 sio.getvalue() 'Hello, there!' import array a = array.array('w', s) print(a) array('w', 'Hello, world') a[0] = 'y' print(a) array('w', 'yello, world') a.tounicode() 'yello, world'"
How do I use strings to call functions/methods?,"There are various techniques. The best is to use a dictionary that maps strings to functions. The primary advantage of this technique is that the strings do not need to match the names of the functions. This is also the primary technique used to emulate a case construct: def a(): pass def b(): pass dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs dispatch[get_input()]()  # Note trailing parens to call function Use the built-in function getattr(): import foo getattr(foo, 'bar')() Note that getattr() works on any object, including classes, class instances, modules, and so on. This is used in several places in the standard library, like this: class Foo: def do_foo(self): ... def do_bar(self): ... f = getattr(foo_instance, 'do_' + opname) f() Use locals() to resolve the function name: def myFunc(): print(""hello"") fname = ""myFunc"" f = locals()[fname] f()"
Is there an equivalent to PerlÉ??s chomp() for removing trailing newlines from strings?,"You can use S.rstrip(""\r\n"") to remove all occurrences of any line terminator from the end of the string S without removing other trailing whitespace. If the string S represents more than one line, with several empty lines at the end, the line terminators for all the blank lines will be removed: lines = (""line 1 \r\n"" ""\r\n"" ""\r\n"") lines.rstrip(""\n\r"") 'line 1 ' Since this is typically only desired when reading text one line at a time, using S.rstrip() this way works well."
Is there a scanf() or sscanf() equivalent?,"Not as such. For simple input parsing, the easiest approach is usually to split the line into whitespace-delimited words using the split() method of string objects and then convert decimal strings to numeric values using int() or float(). split() supports an optional É??sepÉ?ù parameter which is useful if the line uses something other than whitespace as a separator. For more complicated input parsing, regular expressions are more powerful than CÉ??s sscanf and better suited for the task."
What does UnicodeDecodeError or UnicodeEncodeError error mean?,See the Unicode HOWTO.
Can I end a raw string with an odd number of backslashes?,"A raw string ending with an odd number of backslashes will escape the stringÉ??s quote: r'C:\this\will\not\work\' File ""<stdin>"", line 1 r'C:\this\will\not\work\' ^ SyntaxError: unterminated string literal (detected at line 1) There are several workarounds for this. One is to use regular strings and double the backslashes: 'C:\\this\\will\\work\\' 'C:\\this\\will\\work\\' Another is to concatenate a regular string containing an escaped backslash to the raw string: r'C:\this\will\work' '\\' 'C:\\this\\will\\work\\' It is also possible to use os.path.join() to append a backslash on Windows: os.path.join(r'C:\this\will\work', '') 'C:\\this\\will\\work\\' Note that while a backslash will É??escapeÉ?ù a quote for the purposes of determining where the raw string ends, no escaping occurs when interpreting the value of the raw string. That is, the backslash remains present in the value of the raw string: r'backslash\'preserved' ""backslash\\'preserved"" Also see the specification in the language reference. Performance My program is too slow. How do I speed it up? ThatÉ??s a tough one, in general. First, here are a list of things to remember before diving further: Performance characteristics vary across Python implementations. This FAQ focuses on CPython. Behaviour can vary across operating systems, especially when talking about I/O or multi-threading. You should always find the hot spots in your program before attempting to optimize any code (see the profile module). Writing benchmark scripts will allow you to iterate quickly when searching for improvements (see the timeit module). It is highly recommended to have good code coverage (through unit testing or any other technique) before potentially introducing regressions hidden in sophisticated optimizations. That being said, there are many tricks to speed up Python code. Here are some general principles which go a long way towards reaching acceptable performance levels: Making your algorithms faster (or changing to faster ones) can yield much larger benefits than trying to sprinkle micro-optimization tricks all over your code. Use the right data structures. Study documentation for the Built-in Types and the collections module. When the standard library provides a primitive for doing something, it is likely (although not guaranteed) to be faster than any alternative you may come up with. This is doubly true for primitives written in C, such as builtins and some extension types. For example, be sure to use either the list.sort() built-in method or the related sorted() function to do sorting (and see the Sorting Techniques for examples of moderately advanced usage). Abstractions tend to create indirections and force the interpreter to work more. If the levels of indirection outweigh the amount of useful work done, your program will be slower. You should avoid excessive abstraction, especially under the form of tiny functions or methods (which are also often detrimental to readability). If you have reached the limit of what pure Python can allow, there are tools to take you further away. For example, Cython can compile a slightly modified version of Python code into a C extension, and can be used on many different platforms. Cython can take advantage of compilation (and optional type annotations) to make your code significantly faster than when interpreted. If you are confident in your C programming skills, you can also write a C extension module yourself. See also The wiki page devoted to performance tips."
What is the most efficient way to concatenate many strings together?,"str and bytes objects are immutable, therefore concatenating many strings together is inefficient as each concatenation creates a new object. In the general case, the total runtime cost is quadratic in the total string length. To accumulate many str objects, the recommended idiom is to place them into a list and call str.join() at the end: chunks = [] for s in my_strings: chunks.append(s) result = ''.join(chunks) (another reasonably efficient idiom is to use io.StringIO) To accumulate many bytes objects, the recommended idiom is to extend a bytearray object using in-place concatenation (the += operator): result = bytearray() for b in my_bytes_objects: result += b Sequences (Tuples/Lists)"
How do I convert between tuples and lists?,"The type constructor tuple(seq) converts any sequence (actually, any iterable) into a tuple with the same items in the same order. For example, tuple([1, 2, 3]) yields (1, 2, 3) and tuple('abc') yields ('a', 'b', 'c'). If the argument is a tuple, it does not make a copy but returns the same object, so it is cheap to call tuple() when you arenÉ??t sure that an object is already a tuple. The type constructor list(seq) converts any sequence or iterable into a list with the same items in the same order. For example, list((1, 2, 3)) yields [1, 2, 3] and list('abc') yields ['a', 'b', 'c']. If the argument is a list, it makes a copy just like seq[:] would."
WhatÉ??s a negative index?,"Python sequences are indexed with positive numbers and negative numbers. For positive numbers 0 is the first index 1 is the second index and so forth. For negative indices -1 is the last index and -2 is the penultimate (next to last) index and so forth. Think of seq[-n] as the same as seq[len(seq)-n]. Using negative indices can be very convenient. For example S[:-1] is all of the string except for its last character, which is useful for removing the trailing newline from a string."
How do I iterate over a sequence in reverse order?,"Use the reversed() built-in function: for x in reversed(sequence): ...  # do something with x ... This wonÉ??t touch your original sequence, but build a new copy with reversed order to iterate over."
How do you remove duplicates from a list?,"See the Python Cookbook for a long discussion of many ways to do this: https://code.activestate.com/recipes/52560/ If you donÉ??t mind reordering the list, sort it and then scan from the end of the list, deleting duplicates as you go: if mylist: mylist.sort() last = mylist[-1] for i in range(len(mylist)-2, -1, -1): if last == mylist[i]: del mylist[i] else: last = mylist[i] If all elements of the list may be used as set keys (i.e. they are all hashable) this is often faster mylist = list(set(mylist)) This converts the list into a set, thereby removing duplicates, and then back into a list."
How do you remove multiple items from a list,"As with removing duplicates, explicitly iterating in reverse with a delete condition is one possibility. However, it is easier and faster to use slice replacement with an implicit or explicit forward iteration. Here are three variations.: mylist[:] = filter(keep_function, mylist) mylist[:] = (x for x in mylist if keep_condition) mylist[:] = [x for x in mylist if keep_condition] The list comprehension may be fastest."
How do you make an array in Python?,"Use a list: [""this"", 1, ""is"", ""an"", ""array""] Lists are equivalent to C or Pascal arrays in their time complexity; the primary difference is that a Python list can contain objects of many different types. The array module also provides methods for creating arrays of fixed types with compact representations, but they are slower to index than lists. Also note that NumPy and other third party packages define array-like structures with various characteristics as well. To get Lisp-style linked lists, you can emulate cons cells using tuples: lisp_list = (""like"",  (""this"",  (""example"", None) ) ) If mutability is desired, you could use lists instead of tuples. Here the analogue of a Lisp car is lisp_list[0] and the analogue of cdr is lisp_list[1]. Only do this if youÉ??re sure you really need to, because itÉ??s usually a lot slower than using Python lists."
How do I create a multidimensional list?,"You probably tried to make a multidimensional array like this: A = [[None] * 2] * 3 This looks correct if you print it: A [[None, None], [None, None], [None, None]] But when you assign a value, it shows up in multiple places: A[0][0] = 5 A [[5, None], [5, None], [5, None]] The reason is that replicating a list with * doesnÉ??t create copies, it only creates references to the existing objects. The *3 creates a list containing 3 references to the same list of length two. Changes to one row will show in all rows, which is almost certainly not what you want. The suggested approach is to create a list of the desired length first and then fill in each element with a newly created list: A = [None] * 3 for i in range(3): A[i] = [None] * 2 This generates a list containing 3 different lists of length two. You can also use a list comprehension: w, h = 2, 3 A = [[None] * w for i in range(h)] Or, you can use an extension that provides a matrix datatype; NumPy is the best known."
How do I apply a method or function to a sequence of objects?,"To call a method or function and accumulate the return values is a list, a list comprehension is an elegant solution: result = [obj.method() for obj in mylist] result = [function(obj) for obj in mylist] To just run the method or function without saving the return values, a plain for loop will suffice: for obj in mylist: obj.method() for obj in mylist: function(obj)"
Why does a_tuple[i] += [É??itemÉ??] raise an exception when the addition works?,"This is because of a combination of the fact that augmented assignment operators are assignment operators, and the difference between mutable and immutable objects in Python. This discussion applies in general when augmented assignment operators are applied to elements of a tuple that point to mutable objects, but weÉ??ll use a list and += as our exemplar. If you wrote: a_tuple = (1, 2) a_tuple[0] += 1 Traceback (most recent call last): ... TypeError: 'tuple' object does not support item assignment The reason for the exception should be immediately clear: 1 is added to the object a_tuple[0] points to (1), producing the result object, 2, but when we attempt to assign the result of the computation, 2, to element 0 of the tuple, we get an error because we canÉ??t change what an element of a tuple points to. Under the covers, what this augmented assignment statement is doing is approximately this: result = a_tuple[0] + 1 a_tuple[0] = result Traceback (most recent call last): ... TypeError: 'tuple' object does not support item assignment It is the assignment part of the operation that produces the error, since a tuple is immutable. When you write something like: a_tuple = (['foo'], 'bar') a_tuple[0] += ['item'] Traceback (most recent call last): ... TypeError: 'tuple' object does not support item assignment The exception is a bit more surprising, and even more surprising is the fact that even though there was an error, the append worked: a_tuple[0] ['foo', 'item'] To see why this happens, you need to know that (a) if an object implements an __iadd__() magic method, it gets called when the += augmented assignment is executed, and its return value is what gets used in the assignment statement; and (b) for lists, __iadd__() is equivalent to calling extend() on the list and returning the list. ThatÉ??s why we say that for lists, += is a É??shorthandÉ?ù for list.extend(): a_list = [] a_list += [1] a_list [1] This is equivalent to: result = a_list.__iadd__([1]) a_list = result The object pointed to by a_list has been mutated, and the pointer to the mutated object is assigned back to a_list. The end result of the assignment is a no-op, since it is a pointer to the same object that a_list was previously pointing to, but the assignment still happens. Thus, in our tuple example what is happening is equivalent to: result = a_tuple[0].__iadd__(['item']) a_tuple[0] = result Traceback (most recent call last): ... TypeError: 'tuple' object does not support item assignment The __iadd__() succeeds, and thus the list is extended, but even though result points to the same object that a_tuple[0] already points to, that final assignment still results in an error, because tuples are immutable. I want to do a complicated sort: can you do a Schwartzian Transform in Python? The technique, attributed to Randal Schwartz of the Perl community, sorts the elements of a list by a metric which maps each element to its É??sort valueÉ?ù. In Python, use the key argument for the list.sort() method:"
How can I sort one list by values from another list?,"Merge them into an iterator of tuples, sort the resulting list, and then pick out the element you want. list1 = [""what"", ""I'm"", ""sorting"", ""by""] list2 = [""something"", ""else"", ""to"", ""sort""] pairs = zip(list1, list2) pairs = sorted(pairs) pairs [(""I'm"", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')] result = [x[1] for x in pairs] result ['else', 'sort', 'to', 'something'] Objects"
What is a class?,"A class is the particular object type created by executing a class statement. Class objects are used as templates to create instance objects, which embody both the data (attributes) and code (methods) specific to a datatype. A class can be based on one or more other classes, called its base class(es). It then inherits the attributes and methods of its base classes. This allows an object model to be successively refined by inheritance. You might have a generic Mailbox class that provides basic accessor methods for a mailbox, and subclasses such as MboxMailbox, MaildirMailbox, OutlookMailbox that handle various specific mailbox formats."
What is a method?,"A method is a function on some object x that you normally call as x.name(arguments...). Methods are defined as functions inside the class definition: class C: def meth(self, arg): return arg * 2 + self.attribute"
What is self?,"Self is merely a conventional name for the first argument of a method. A method defined as meth(self, a, b, c) should be called as x.meth(a, b, c) for some instance x of the class in which the definition occurs; the called method will think it is called as meth(x, a, b, c). See also Why must É??selfÉ?? be used explicitly in method definitions and calls?."
How do I check if an object is an instance of a given class or of a subclass of it?,"Use the built-in function isinstance(obj, cls). You can check if an object is an instance of any of a number of classes by providing a tuple instead of a single class, e.g. isinstance(obj, (class1, class2, ...)), and can also check whether an object is one of PythonÉ??s built-in types, e.g. isinstance(obj, str) or isinstance(obj, (int, float, complex)). Note that isinstance() also checks for virtual inheritance from an abstract base class. So, the test will return True for a registered class even if hasnÉ??t directly or indirectly inherited from it. To test for É??true inheritanceÉ?ù, scan the MRO of the class: from collections.abc import Mapping class P: pass class C(P): pass Mapping.register(P) c = C()"
"isinstance(c, C)        # direct",TRUE
"isinstance(c, P)        # indirect",TRUE
"isinstance(c, Mapping)  # virtual","True # Actual inheritance chain type(c).__mro__ (<class 'C'>, <class 'P'>, <class 'object'>) # Test for ""true inheritance"" Mapping in type(c).__mro__ False Note that most programs do not use isinstance() on user-defined classes very often. If you are developing the classes yourself, a more proper object-oriented style is to define methods on the classes that encapsulate a particular behaviour, instead of checking the objectÉ??s class and doing a different thing based on what class it is. For example, if you have a function that does something: def search(obj): if isinstance(obj, Mailbox): ...  # code to search a mailbox elif isinstance(obj, Document): ...  # code to search a document elif ... A better approach is to define a search() method on all the classes and just call it: class Mailbox: def search(self): ...  # code to search a mailbox class Document: def search(self): ...  # code to search a document obj.search()"
What is delegation?,"Delegation is an object oriented technique (also called a design pattern). LetÉ??s say you have an object x and want to change the behaviour of just one of its methods. You can create a new class that provides a new implementation of the method youÉ??re interested in changing and delegates all other methods to the corresponding method of x. Python programmers can easily implement delegation. For example, the following class implements a class that behaves like a file but converts all written data to uppercase: class UpperOut: def __init__(self, outfile): self._outfile = outfile def write(self, s): self._outfile.write(s.upper()) def __getattr__(self, name): return getattr(self._outfile, name) Here the UpperOut class redefines the write() method to convert the argument string to uppercase before calling the underlying self._outfile.write() method. All other methods are delegated to the underlying self._outfile object. The delegation is accomplished via the __getattr__() method; consult the language reference for more information about controlling attribute access. Note that for more general cases delegation can get trickier. When attributes must be set as well as retrieved, the class must define a __setattr__() method too, and it must do so carefully. The basic implementation of __setattr__() is roughly equivalent to the following: class X: ... def __setattr__(self, name, value): self.__dict__[name] = value ... Many __setattr__() implementations call object.__setattr__() to set an attribute on self without causing infinite recursion: class X: def __setattr__(self, name, value): # Custom logic here... object.__setattr__(self, name, value) Alternatively, it is possible to set attributes by inserting entries into self.__dict__ directly."
How do I call a method defined in a base class from a derived class that extends it?,"Use the built-in super() function: class Derived(Base): def meth(self): super().meth()  # calls Base.meth In the example, super() will automatically determine the instance from which it was called (the self value), look up the method resolution order (MRO) with type(self).__mro__, and return the next in line after Derived in the MRO: Base."
How can I organize my code to make it easier to change the base class?,"You could assign the base class to an alias and derive from the alias. Then all you have to change is the value assigned to the alias. Incidentally, this trick is also handy if you want to decide dynamically (e.g. depending on availability of resources) which base class to use. Example: class Base: ... BaseAlias = Base class Derived(BaseAlias): ..."
How do I create static class data and static class methods?,"Both static data and static methods (in the sense of C++ or Java) are supported in Python. For static data, simply define a class attribute. To assign a new value to the attribute, you have to explicitly use the class name in the assignment: class C: count = 0   # number of times C.__init__ called def __init__(self): C.count = C.count + 1 def getcount(self): return C.count  # or return self.count c.count also refers to C.count for any c such that isinstance(c, C) holds, unless overridden by c itself or by some class on the base-class search path from c.__class__ back to C. Caution: within a method of C, an assignment like self.count = 42 creates a new and unrelated instance named É??countÉ?ù in selfÉ??s own dict. Rebinding of a class-static data name must always specify the class whether inside a method or not: C.count = 314 Static methods are possible: class C: @staticmethod def static(arg1, arg2, arg3): # No 'self' parameter! ..."
"However, a far more straightforward way to get the effect of a static method is via a simple module-level function:","def getcount(): return C.count If your code is structured so as to define one class (or tightly related class hierarchy) per module, this supplies the desired encapsulation."
How can I overload constructors (or methods) in Python?,"This answer actually applies to all methods, but the question usually comes up first in the context of constructors. In C++ youÉ??d write class C { C() { cout << ""No arguments\n""; } C(int i) { cout << ""Argument is "" << i << ""\n""; } } In Python you have to write a single constructor that catches all cases using default arguments. For example: class C: def __init__(self, i=None): if i is None: print(""No arguments"") else: print(""Argument is"", i) This is not entirely equivalent, but close enough in practice. You could also try a variable-length argument list, e.g. def __init__(self, *args): ... The same approach works for all method definitions. I try to use __spam and I get an error about _SomeClassName__spam. Variable names with double leading underscores are É??mangledÉ?ù to provide a simple but effective way to define class private variables. Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with any leading underscores stripped. The identifier can be used unchanged within the class, but to access it outside the class, the mangled name must be used: class A: def __one(self): return 1 def two(self): return 2 * self.__one() class B(A): def three(self): return 3 * self._A__one() four = 4 * A()._A__one() In particular, this does not guarantee privacy since an outside user can still deliberately access the private attribute; many Python programmers never bother to use private variable names at all. See also The private name mangling specifications for details and special cases. My class defines __del__ but it is not called when I delete the object. There are several possible reasons for this. The del statement does not necessarily call __del__() É?? it simply decrements the objectÉ??s reference count, and if this reaches zero __del__() is called. If your data structures contain circular links (e.g. a tree where each child has a parent reference and each parent has a list of children) the reference counts will never go back to zero. Once in a while Python runs an algorithm to detect such cycles, but the garbage collector might run some time after the last reference to your data structure vanishes, so your __del__() method may be called at an inconvenient and random time. This is inconvenient if youÉ??re trying to reproduce a problem. Worse, the order in which objectÉ??s __del__() methods are executed is arbitrary. You can run gc.collect() to force a collection, but there are pathological cases where objects will never be collected. Despite the cycle collector, itÉ??s still a good idea to define an explicit close() method on objects to be called whenever youÉ??re done with them. The close() method can then remove attributes that refer to subobjects. DonÉ??t call __del__() directly É?? __del__() should call close() and close() should make sure that it can be called more than once for the same object. Another way to avoid cyclical references is to use the weakref module, which allows you to point to objects without incrementing their reference count. Tree data structures, for instance, should use weak references for their parent and sibling references (if they need them!). Finally, if your __del__() method raises an exception, a warning message is printed to sys.stderr."
How do I get a list of all instances of a given class?,Python does not keep track of all instances of a class (or of a built-in type). You can program the classÉ??s constructor to keep track of all instances by keeping a list of weak references to each instance.
Why does the result of id() appear to be not unique?,"The id() builtin returns an integer that is guaranteed to be unique during the lifetime of the object. Since in CPython, this is the objectÉ??s memory address, it happens frequently that after an object is deleted from memory, the next freshly created object is allocated at the same position in memory. This is illustrated by this example: id(1000) 13901272 id(2000) 13901272 The two ids belong to different integer objects that are created before, and deleted immediately after execution of the id() call. To be sure that objects whose id you want to examine are still alive, create another reference to the object: a = 1000; b = 2000 id(a) 13901272 id(b) 13891296 When can I rely on identity tests with the is operator? The is operator tests for object identity. The test a is b is equivalent to id(a) == id(b). The most important property of an identity test is that an object is always identical to itself, a is a always returns True. Identity tests are usually faster than equality tests. And unlike equality tests, identity tests are guaranteed to return a boolean True or False."
"However, identity tests can only be substituted for equality tests when object identity is assured. Generally, there are three circumstances where identity is guaranteed:","Assignments create new names but do not change object identity. After the assignment new = old, it is guaranteed that new is old. Putting an object in a container that stores object references does not change object identity. After the list assignment s[0] = x, it is guaranteed that s[0] is x. If an object is a singleton, it means that only one instance of that object can exist. After the assignments a = None and b = None, it is guaranteed that a is b because None is a singleton. In most other circumstances, identity tests are inadvisable and equality tests are preferred. In particular, identity tests should not be used to check constants such as int and str which arenÉ??t guaranteed to be singletons: a = 1000 b = 500 c = b + 500 a is c False a = 'Python' b = 'Py' c = b + 'thon' a is c False Likewise, new instances of mutable containers are never identical: a = [] b = [] a is b False In the standard library code, you will see several common patterns for correctly using identity tests: As recommended by PEP 8, an identity test is the preferred way to check for None. This reads like plain English in code and avoids confusion with other objects that may have boolean values that evaluate to false. Detecting optional arguments can be tricky when None is a valid input value. In those situations, you can create a singleton sentinel object guaranteed to be distinct from other objects. For example, here is how to implement a method that behaves like dict.pop(): _sentinel = object() def pop(self, key, default=_sentinel): if key in self: value = self[key] del self[key] return value if default is _sentinel: raise KeyError(key) return default Container implementations sometimes need to augment equality tests with identity tests. This prevents the code from being confused by objects such as float('NaN') that are not equal to themselves. For example, here is the implementation of collections.abc.Sequence.__contains__(): def __contains__(self, value): for v in self: if v is value or v == value: return True return False"
How can a subclass control what data is stored in an immutable instance?,"When subclassing an immutable type, override the __new__() method instead of the __init__() method. The latter only runs after an instance is created, which is too late to alter data in an immutable instance. All of these immutable classes have a different signature than their parent class: from datetime import date class FirstOfMonthDate(date): ""Always choose the first day of the month"" def __new__(cls, year, month, day): return super().__new__(cls, year, month, 1) class NamedInt(int): ""Allow text names for some numbers"" xlat = {'zero': 0, 'one': 1, 'ten': 10} def __new__(cls, value): value = cls.xlat.get(value, value) return super().__new__(cls, value) class TitleStr(str): ""Convert str to name suitable for a URL path"" def __new__(cls, s): s = s.lower().replace(' ', '-') s = ''.join([c for c in s if c.isalnum() or c == '-']) return super().__new__(cls, s) The classes can be used like this: FirstOfMonthDate(2012, 2, 14) FirstOfMonthDate(2012, 2, 1) NamedInt('ten') 10 NamedInt(20) 20 TitleStr('Blog: Why Python Rocks') 'blog-why-python-rocks'"
How do I cache method calls?,"The two principal tools for caching methods are functools.cached_property() and functools.lru_cache(). The former stores results at the instance level and the latter at the class level. The cached_property approach only works with methods that do not take any arguments. It does not create a reference to the instance. The cached method result will be kept only as long as the instance is alive. The advantage is that when an instance is no longer used, the cached method result will be released right away. The disadvantage is that if instances accumulate, so too will the accumulated method results. They can grow without bound. The lru_cache approach works with methods that have hashable arguments. It creates a reference to the instance unless special efforts are made to pass in weak references. The advantage of the least recently used algorithm is that the cache is bounded by the specified maxsize. The disadvantage is that instances are kept alive until they age out of the cache or until the cache is cleared. This example shows the various techniques: class Weather: ""Lookup weather information on a government website"" def __init__(self, station_id): self._station_id = station_id # The _station_id is private and immutable def current_temperature(self): ""Latest hourly observation"" # Do not cache this because old results # can be out of date. @cached_property def location(self): ""Return the longitude/latitude coordinates of the station"" # Result only depends on the station_id @lru_cache(maxsize=20) def historic_rainfall(self, date, units='mm'): ""Rainfall on a given date"" # Depends on the station_id, date, and units. The above example assumes that the station_id never changes. If the relevant instance attributes are mutable, the cached_property approach canÉ??t be made to work because it cannot detect changes to the attributes. To make the lru_cache approach work when the station_id is mutable, the class needs to define the __eq__() and __hash__() methods so that the cache can detect relevant attribute updates: class Weather: ""Example with a mutable station identifier"" def __init__(self, station_id): self.station_id = station_id def change_station(self, station_id): self.station_id = station_id def __eq__(self, other): return self.station_id == other.station_id def __hash__(self): return hash(self.station_id) @lru_cache(maxsize=20) def historic_rainfall(self, date, units='cm'): 'Rainfall on a given date' # Depends on the station_id, date, and units. Modules"
How do I create a .pyc file?,"When a module is imported for the first time (or when the source file has changed since the current compiled file was created) a .pyc file containing the compiled code should be created in a __pycache__ subdirectory of the directory containing the .py file. The .pyc file will have a filename that starts with the same name as the .py file, and ends with .pyc, with a middle component that depends on the particular python binary that created it. (See PEP 3147 for details.) One reason that a .pyc file may not be created is a permissions problem with the directory containing the source file, meaning that the __pycache__ subdirectory cannot be created. This can happen, for example, if you develop as one user but run as another, such as if you are testing with a web server. Unless the PYTHONDONTWRITEBYTECODE environment variable is set, creation of a .pyc file is automatic if youÉ??re importing a module and Python has the ability (permissions, free space, etcÉ??) to create a __pycache__ subdirectory and write the compiled module to that subdirectory. Running Python on a top level script is not considered an import and no .pyc will be created. For example, if you have a top-level module foo.py that imports another module xyz.py, when you run foo (by typing python foo.py as a shell command), a .pyc will be created for xyz because xyz is imported, but no .pyc file will be created for foo since foo.py isnÉ??t being imported. If you need to create a .pyc file for foo É?? that is, to create a .pyc file for a module that is not imported É?? you can, using the py_compile and compileall modules. The py_compile module can manually compile any module. One way is to use the compile() function in that module interactively: import py_compile py_compile.compile('foo.py') This will write the .pyc to a __pycache__ subdirectory in the same location as foo.py (or you can override that with the optional parameter cfile). You can also automatically compile all files in a directory or directories using the compileall module. You can do it from the shell prompt by running compileall.py and providing the path of a directory containing Python files to compile: python -m compileall ."
How do I find the current module name?,"A module can find out its own module name by looking at the predefined global variable __name__. If this has the value '__main__', the program is running as a script. Many modules that are usually used by importing them also provide a command-line interface or a self-test, and only execute this code after checking __name__: def main(): print('Running test...') ... if __name__ == '__main__': main()"
How can I have modules that mutually import each other?,"Suppose you have the following modules: foo.py: from bar import bar_var foo_var = 1 bar.py: from foo import foo_var bar_var = 2 The problem is that the interpreter will perform the following steps: main imports foo Empty globals for foo are created foo is compiled and starts executing foo imports bar Empty globals for bar are created bar is compiled and starts executing bar imports foo (which is a no-op since there already is a module named foo) The import mechanism tries to read foo_var from foo globals, to set bar.foo_var = foo.foo_var The last step fails, because Python isnÉ??t done with interpreting foo yet and the global symbol dictionary for foo is still empty. The same thing happens when you use import foo, and then try to access foo.foo_var in global code. There are (at least) three possible workarounds for this problem. Guido van Rossum recommends avoiding all uses of from <module> import ..., and placing all code inside functions. Initializations of global variables and class variables should use constants or built-in functions only. This means everything from an imported module is referenced as <module>.<name>. Jim Roskind suggests performing steps in the following order in each module: exports (globals, functions, and classes that donÉ??t need imported base classes) import statements active code (including globals that are initialized from imported values). Van Rossum doesnÉ??t like this approach much because the imports appear in a strange place, but it does work. Matthias Urlichs recommends restructuring your code so that the recursive import is not necessary in the first place. These solutions are not mutually exclusive. __import__(É??x.y.zÉ??) returns <module É??xÉ??>; how do I get z? Consider using the convenience function import_module() from importlib instead: z = importlib.import_module('x.y.z') When I edit an imported module and reimport it, the changes donÉ??t show up. Why does this happen? For reasons of efficiency as well as consistency, Python only reads the module file on the first time a module is imported. If it didnÉ??t, in a program consisting of many modules where each one imports the same basic module, the basic module would be parsed and re-parsed many times. To force re-reading of a changed module, do this: import importlib import modname importlib.reload(modname) Warning: this technique is not 100% fool-proof. In particular, modules containing statements like from modname import some_objects will continue to work with the old version of the imported objects. If the module contains class definitions, existing class instances will not be updated to use the new class definition. This can result in the following paradoxical behaviour: import importlib import cls c = cls.C()                # Create an instance of C importlib.reload(cls) <module 'cls' from 'cls.py'>"
"isinstance(c, cls.C)       # isinstance is false?!?",False The nature of the problem is made clear if you print out the É??identityÉ?ù of the class objects: Copy hex(id(c.__class__)) '0x7352a0' hex(id(cls.C)) '0x4198d0'
How do I run a Python program under Windows?,"This is not necessarily a straightforward question. If you are already familiar with running programs from the Windows command line then everything will seem obvious; otherwise, you might need a little more guidance. Unless you use some sort of integrated development environment, you will end up typing Windows commands into what is referred to as a É??Command prompt windowÉ?ù. Usually you can create such a window from your search bar by searching for cmd. You should be able to recognize when you have started such a window because you will see a Windows É??command promptÉ?ù, which usually looks like this: The letter may be different, and there might be other things after it, so you might just as easily see something like: depending on how your computer has been set up and what else you have recently done with it. Once you have started such a window, you are well on the way to running Python programs. You need to realize that your Python scripts have to be processed by another program called the Python interpreter. The interpreter reads your script, compiles it into bytecodes, and then executes the bytecodes to run your program. So, how do you arrange for the interpreter to handle your Python? First, you need to make sure that your command window recognises the word É??pyÉ?ù as an instruction to start the interpreter. If you have opened a command window, you should try entering the command py and hitting return: py You should then see something like: Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)] on win32 Type ""help"", ""copyright"", ""credits"" or ""license"" for more information. You have started the interpreter in É??interactive modeÉ?ù. That means you can enter Python statements or expressions interactively and have them executed or evaluated while you wait. This is one of PythonÉ??s strongest features. Check it by entering a few expressions of your choice and seeing the results: print(""Hello"") Hello ""Hello"" * 3 'HelloHelloHello' Many people use the interactive mode as a convenient yet highly programmable calculator. When you want to end your interactive Python session, call the exit() function or hold the Ctrl key down while you enter a Z, then hit the É??EnterÉ?ù key to get back to your Windows command prompt. You may also find that you have a Start-menu entry such as Start É?ú Programs É?ú Python 3.x É?ú Python (command line) that results in you seeing the >>> prompt in a new window. If so, the window will disappear after you call the exit() function or enter the Ctrl-Z character; Windows is running a single É??pythonÉ?ù command in the window, and closes it when you terminate the interpreter. Now that we know the py command is recognized, you can give your Python script to it. YouÉ??ll have to give either an absolute or a relative path to the Python script. LetÉ??s say your Python script is located in your desktop and is named hello.py, and your command prompt is nicely opened in your home directory so youÉ??re seeing something similar to: C:\Users\YourName> So now youÉ??ll ask the py command to give your script to Python by typing py followed by your script path: C:\Users\YourName> py Desktop\hello.py hello"
How do I make Python scripts executable?,"On Windows, the standard Python installer already associates the .py extension with a file type (Python.File) and gives that file type an open command that runs the interpreter (D:\Program Files\Python\python.exe ""%1"" %*). This is enough to make scripts executable from the command prompt as É??foo.pyÉ??. If youÉ??d rather be able to execute the script by simple typing É??fooÉ?? with no extension you need to add .py to the PATHEXT environment variable."
Why does Python sometimes take so long to start?,"Usually Python starts very quickly on Windows, but occasionally there are bug reports that Python suddenly begins to take a long time to start up. This is made even more puzzling because Python will work fine on other Windows systems which appear to be configured identically. The problem may be caused by a misconfiguration of virus checking software on the problem machine. Some virus scanners have been known to introduce startup overhead of two orders of magnitude when the scanner is configured to monitor all reads from the filesystem. Try checking the configuration of virus scanning software on your systems to ensure that they are indeed configured identically. McAfee, when configured to scan all file system read activity, is a particular offender."
How do I make an executable from a Python script?,See How can I create a stand-alone binary from a Python script? for a list of tools that can be used to make executables.
Is a *.pyd file the same as a DLL?,"Yes, .pyd files are dllÉ??s, but there are a few differences. If you have a DLL named foo.pyd, then it must have a function PyInit_foo(). You can then write Python É??import fooÉ?ù, and Python will search for foo.pyd (as well as foo.py, foo.pyc) and if it finds it, will attempt to call PyInit_foo() to initialize it. You do not link your .exe with foo.lib, as that would cause Windows to require the DLL to be present. Note that the search path for foo.pyd is PYTHONPATH, not the same as the path that Windows uses to search for foo.dll. Also, foo.pyd need not be present to run your program, whereas if you linked your program with a dll, the dll is required. Of course, foo.pyd is required if you want to say import foo. In a DLL, linkage is declared in the source code with __declspec(dllexport). In a .pyd, linkage is defined in a list of available functions."
How can I embed Python into a Windows application?,"Embedding the Python interpreter in a Windows app can be summarized as follows: Do not build Python into your .exe file directly. On Windows, Python must be a DLL to handle importing modules that are themselves DLLÉ??s. (This is the first key undocumented fact.) Instead, link to pythonNN.dll; it is typically installed in C:\Windows\System. NN is the Python version, a number such as É??33É?ù for Python 3.3. You can link to Python in two different ways. Load-time linking means linking against pythonNN.lib, while run-time linking means linking against pythonNN.dll. (General note: pythonNN.lib is the so-called É??import libÉ?ù corresponding to pythonNN.dll. It merely defines symbols for the linker.) Run-time linking greatly simplifies link options; everything happens at run time. Your code must load pythonNN.dll using the Windows LoadLibraryEx() routine. The code must also use access routines and data in pythonNN.dll (that is, PythonÉ??s C APIÉ??s) using pointers obtained by the Windows GetProcAddress() routine. Macros can make using these pointers transparent to any C code that calls routines in PythonÉ??s C API. If you use SWIG, it is easy to create a Python É??extension moduleÉ?ù that will make the appÉ??s data and methods available to Python. SWIG will handle just about all the grungy details for you. The result is C code that you link into your .exe file (!) You do not have to create a DLL file, and this also simplifies linking. SWIG will create an init function (a C function) whose name depends on the name of the extension module. For example, if the name of the module is leo, the init function will be called initleo(). If you use SWIG shadow classes, as you should, the init function will be called initleoc(). This initializes a mostly hidden helper class used by the shadow class. The reason you can link the C code in step 2 into your .exe file is that calling the initialization function is equivalent to importing the module into Python! (This is the second key undocumented fact.) In short, you can use the following code to initialize the Python interpreter with your extension module. #include <Python.h> ... Py_Initialize();  // Initialize Python. initmyAppc();  // Initialize (import) the helper class. PyRun_SimpleString(""import myApp"");  // Import the shadow class. There are two problems with PythonÉ??s C API which will become apparent if you use a compiler other than MSVC, the compiler used to build pythonNN.dll. Problem 1: The so-called É??Very High LevelÉ?ù functions that take FILE * arguments will not work in a multi-compiler environment because each compilerÉ??s notion of a struct FILE will be different. From an implementation standpoint these are very low level functions. Problem 2: SWIG generates the following code when generating wrappers to void functions: Py_INCREF(Py_None); _resultobj = Py_None; return _resultobj; Alas, Py_None is a macro that expands to a reference to a complex data structure called _Py_NoneStruct inside pythonNN.dll. Again, this code will fail in a mult-compiler environment. Replace such code by: return Py_BuildValue(""""); It may be possible to use SWIGÉ??s %typemap command to make the change automatically, though I have not been able to get this to work (IÉ??m a complete SWIG newbie). Using a Python shell script to put up a Python interpreter window from inside your Windows app is not a good idea; the resulting window will be independent of your appÉ??s windowing system. Rather, you (or the wxPythonWindow class) should create a É??nativeÉ?ù interpreter window. It is easy to connect that window to the Python interpreter. You can redirect PythonÉ??s i/o to _any_ object that supports read and write, so all you need is a Python object (defined in your extension module) that contains read() and write() methods."
How do I keep editors from inserting tabs into my Python source?,"The FAQ does not recommend using tabs, and the Python style guide, PEP 8, recommends 4 spaces for distributed Python code; this is also the Emacs python-mode default. Under any editor, mixing tabs and spaces is a bad idea. MSVC is no different in this respect, and is easily configured to use spaces: Take Tools É?ú Options É?ú Tabs, and for file type É??DefaultÉ?ù set É??Tab sizeÉ?ù and É??Indent sizeÉ?ù to 4, and select the É??Insert spacesÉ?ù radio button. Python raises IndentationError or TabError if mixed tabs and spaces are causing problems in leading whitespace. You may also run the tabnanny module to check a directory tree in batch mode."
How do I check for a keypress without blocking?,"Use the msvcrt module. This is a standard Windows-specific extension module. It defines a function kbhit() which checks whether a keyboard hit is present, and getch() which gets one character without echoing it."
How do I solve the missing api-ms-win-crt-runtime-l1-1-0.dll error?,"This can occur on Python 3.5 and later when using Windows 8.1 or earlier without all updates having been installed. First ensure your operating system is supported and is up to date, and if that does not resolve the issue, visit the Microsoft support page for guidance on manually installing the C Runtime update."
What is Python?,"Python is a programming language. ItÉ??s used for many different applications. ItÉ??s used in some high schools and colleges as an introductory programming language because Python is easy to learn, but itÉ??s also used by professional software developers at places such as Google, NASA, and Lucasfilm Ltd. If you wish to learn more about Python, start with the BeginnerÉ??s Guide to Python."
Why is Python installed on my machine?,"If you find Python installed on your system but donÉ??t remember installing it, there are several possible ways it could have gotten there. Perhaps another user on the computer wanted to learn programming and installed it; youÉ??ll have to figure out whoÉ??s been using the machine and might have installed it. A third-party application installed on the machine might have been written in Python and included a Python installation. There are many such applications, from GUI programs to network servers and administrative scripts. Some Windows machines also have Python installed. At this writing weÉ??re aware of computers from Hewlett-Packard and Compaq that include Python. Apparently some of HP/CompaqÉ??s administrative tools are written in Python. Many Unix-compatible operating systems, such as macOS and some Linux distributions, have Python installed by default; itÉ??s included in the base installation."
Can I delete Python?,"That depends on where Python came from. If someone installed it deliberately, you can remove it without hurting anything. On Windows, use the Add/Remove Programs icon in the Control Panel. If Python was installed by a third-party application, you can also remove it, but that application will no longer work. You should use that applicationÉ??s uninstaller rather than removing Python directly. If Python came with your operating system, removing it is not recommended. If you remove it, whatever tools were written in Python will no longer run, and some of them might be important to you. Reinstalling the whole system would then be required to fix things again."
